#include <iostream>
/* 
    Notes :  Default constructors and default arguments

    1. A default constructor is a constructor that accepts no arguments. Typically, this is a constructor that has been defined with no parameters.

    2. Value initialization vs default initialization for class types - 

        If a class type has a default constructor, both value initialization and default initialization will call the default constructor. Thus, for such a class such as the Foo class in the example above, the following are essentially equivalent:

        Foo foo{}; // value initialization, calls Foo() default constructor
        Foo foo2;  // default initialization, calls Foo() default constructor

        Prefer value initialization over default initialization for all class types.

    3. Constructors with default arguments - As with all functions, the rightmost parameters of constructors can have default arguments.

        class Foo
        {
        private:
            int m_x { };
            int m_y { };

        public:
            Foo(int x=0, int y=0) // has default arguments
                : m_x { x }
                , m_y { y }
            {
                std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
            }
        };

    4. Overloaded constructors - Because constructors are functions, they can be overloaded. That is, we can have multiple constructors so that we can construct objects in different ways:

        class Foo
        {
        private:
            int m_x {};
            int m_y {};

        public:
            Foo() // default constructor
            {
                std::cout << "Foo constructed\n";
            }

            Foo(int x, int y) // non-default constructor
                : m_x { x }, m_y { y }
            {
                std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
            }
        };

        A corollary of the above is that a class should only have one default constructor. If more than one default constructor is provided, the compiler will be unable to disambiguate which should be used.

    5. An implicit default constructor - 

        If a non-aggregate class type object has no user-declared constructors, the compiler will generate a public default constructor (so that the class can be value or default initialized). This constructor is called an implicit default constructor.

        class Foo
        {
        private:
            int m_x{};
            int m_y{};

            // Note: no constructors declared
        };

        This class has no user-declared constructors, so the compiler will generate an implicit default constructor for us. That constructor will be used to instantiate foo{}.

        The implicit default constructor is equivalent to a constructor that has no parameters, no member initializer list, and no statements in the body of the constructor. In other words, for the above Foo class, the compiler generates this:

            public:
            Foo() // implicitly generated default constructor
            {
            }

    6. Using = default to generate an explicitly defaulted default constructor 

        In cases where we would write a default constructor that is equivalent to the implicitly generated default constructor, we can instead tell the compiler to generate a default constructor for us. This constructor is called an explicitly defaulted default constructor, and it can be generated by using the = default syntax:

            class Foo
            {
            private:
                int m_x {};
                int m_y {};

            public:
                Foo() = default; // generates an explicitly defaulted default constructor

                Foo(int x, int y)
                    : m_x { x }, m_y { y }
                {
                    std::cout << "Foo(" << m_x << ", " << m_y << ") constructed\n";
                }
            };

    7. Explicitly defaulted default constructor vs empty user-defined constructor - 

        1. There are at least two cases where the explicitly defaulted default constructor behaves differently than an empty user-defined constructor.

            - When value initializing a class, if the class has a user-defined default constructor, the object will be default initialized. However, if the class has a default constructor that is not user-provided (that is, a default constructor that is either implicitly defined, or defined using = default), the object will be zero-initialized before being default initialized.

            class User
            {
            private:
                int m_a; // note: no default initialization value
                int m_b {};

            public:
                User() {} // user-defined empty constructor

                int a() const { return m_a; }
                int b() const { return m_b; }
            };

            class Default
            {
            private:
                int m_a; // note: no default initialization value
                int m_b {};

            public:
                Default() = default; // explicitly defaulted default constructor

                int a() const { return m_a; }
                int b() const { return m_b; }
            };

            class Implicit
            {
            private:
                int m_a; // note: no default initialization value
                int m_b {};

            public:
                // implicit default constructor

                int a() const { return m_a; }
                int b() const { return m_b; }
            };

            int main()
            {
                User user{}; // default initialized
                std::cout << user.a() << ' ' << user.b() << '\n';

                Default def{}; // zero initialized, then default initialized
                std::cout << def.a() << ' ' << def.b() << '\n';

                Implicit imp{}; // zero initialized, then default initialized
                std::cout << imp.a() << ' ' << imp.b() << '\n';

                return 0;
            }

        2. Prior to C++20, a class with a user-defined default constructor (even if it has an empty body) makes the class a non-aggregate, whereas an explicitly defaulted default constructor does not. Assuming the class was otherwise an aggregate, the former would cause the class to use list initialization instead of aggregate initialization. In C++20 onward, this inconsistency was addressed, so that both make the class a non-aggregate.

    8. Only create a default constructor when it makes sense - 

        - A default constructor allows us to create objects of a non-aggregate class type with no user-provided initialization values. Thus, a class should only provide a default constructor when it makes sense for objects of a class type to be created using all default values.

            class Fraction
            {
            private:
                int m_numerator{ 0 };
                int m_denominator{ 1 };

            public:
                Fraction() = default;
                Fraction(int numerator, int denominator)
                    : m_numerator{ numerator }
                    , m_denominator{ denominator }
                {
                }

                void print() const
                {
                    std::cout << "Fraction(" << m_numerator << ", " << m_denominator << ")\n";
                }
            };

        - For a class representing a fraction, it makes sense to allow the user to create Fraction objects with no initializers (in which case, the user will get the fraction 0/1).

        - Now consider this class:

            class Employee
            {
            private:
                std::string m_name{ };
                int m_id{ };

            public:
                Employee(std::string_view name, int id)
                    : m_name{ name }
                    , m_id{ id }
                {
                }

                void print() const
                {
                    std::cout << "Employee(" << m_name << ", " << m_id << ")\n";
                }
            };

        - For a class representing an employee, it doesnâ€™t make sense to allow creation of employees with no name. Thus, such a class should not have a default constructor, so that a compilation error will result if the user of the class tries to do so.

*/


class User
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    User() {} // user-defined empty constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

class Default
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    Default() = default; // explicitly defaulted default constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

class Implicit
{
private:
    int m_a; // note: no default initialization value
    int m_b {};

public:
    // implicit default constructor

    int a() const { return m_a; }
    int b() const { return m_b; }
};

int main()
{
    User user{}; // default initialized
    std::cout << user.a() << ' ' << user.b() << '\n';

    Default def{}; // zero initialized, then default initialized
    std::cout << def.a() << ' ' << def.b() << '\n';

    Implicit imp{}; // zero initialized, then default initialized
    std::cout << imp.a() << ' ' << imp.b() << '\n';

    return 0;
}